/*
 * generated by Xtext 2.25.0
 */
package org.piacere.dsl.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.piacere.dsl.dOML.CInputVariable;
import org.piacere.dsl.dOML.CMultipleNestedProperty;
import org.piacere.dsl.dOML.CMultipleValueExpression;
import org.piacere.dsl.dOML.CNode;
import org.piacere.dsl.dOML.CNodeNestedProperty;
import org.piacere.dsl.dOML.CNodeProperty;
import org.piacere.dsl.dOML.CRefInputVariable;
import org.piacere.dsl.dOML.DOMLPackage;
import org.piacere.dsl.dOML.impl.CBOOLEANImpl;
import org.piacere.dsl.dOML.impl.CFLOATImpl;
import org.piacere.dsl.dOML.impl.CMultipleValueExpressionImpl;
import org.piacere.dsl.dOML.impl.CNodeNestedPropertyImpl;
import org.piacere.dsl.dOML.impl.CRefInputVariableImpl;
import org.piacere.dsl.dOML.impl.CSIGNEDINTImpl;
import org.piacere.dsl.dOML.impl.CSTRINGImpl;
import org.piacere.dsl.rMDF.CProperty;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class DOMLValidator extends AbstractDOMLValidator {

	//	public static final String INVALID_NAME = "invalidName";

	/**
	 * Check the required properties of a CNode are satisfied.
	 * @param node
	 */
	@Check
	public void checkNodeRequirements(CNode node) {
		
		List<CProperty> props = EcoreUtil2.getAllContentsOfType(node.getType(), CProperty.class);
		List<CNodeProperty> properties = node.getProperties();
		
		this.checkNestedPropertyRequirements(props, properties, 
				DOMLPackage.Literals.CNODE__PROPERTIES);
	}
	
	/**
	 * Check the required properties of a NestedProperty which is defined
	 * by a datatype are satisfied.
	 * @param node
	 */
	@Check
	public void checkNodeRequirements(CNodeNestedProperty node) {
		
		EObject container = this.getContainer(node);
		// Leave the multiple check to its own method
		if (EcoreUtil2.getContainerOfType(node, CMultipleValueExpression.class) != null)
			return;
		
		List<CProperty> props = EcoreUtil2.getAllContentsOfType(container, CProperty.class);
		List<CNodeProperty> properties = node.getProperties();
		
		this.checkNestedPropertyRequirements(props, properties,
				DOMLPackage.Literals.CNODE_NESTED_PROPERTY__PROPERTIES);
	}
	
	/**
	 * Check the required properties on a multiple nested property.
	 * @param node
	 */
	@Check
	public void checkNodeRequirements(CMultipleNestedProperty node) {

		EObject container = this.getContainer(node);
		List<CProperty> props = EcoreUtil2.getAllContentsOfType(container, CProperty.class);
		List<CNodeProperty> properties = new ArrayList<CNodeProperty>();
		properties.add(node.getFirst());
		if (node.getRest() != null)
			properties.addAll(node.getRest().getProperties());
		
		this.checkNestedPropertyRequirements(props, properties,
				DOMLPackage.Literals.CMULTIPLE_NESTED_PROPERTY__FIRST);
	}
	
	/**
	 * Check if all the required properties are actually defined or not.
	 * 
	 * @param defined set of properties definition
	 * @param used set of properties used
	 * @param reference the reference where the error should be displayed
	 */
	protected void checkNestedPropertyRequirements(List<CProperty> defined, 
			List<CNodeProperty> used,
			EReference reference) {
		
		List<String> propertiesRequired = defined
				.stream()
				.filter(this::isRequired)
				.map((prop) -> prop.getName())
				.collect(Collectors.toList());

		List<String> currentProperties = used
				.stream()
				.map((prop) -> prop.getName().getName())
				.collect(Collectors.toList());
		
		if (!currentProperties.containsAll(propertiesRequired))
			error("Some required properties are missing: " + propertiesRequired.toString(), reference);
	}
	
	/**
	 * Get container of a given EObject. The container could be a nested property
	 * which is declared with a Datatype or a CNode.
	 * @param obj object
	 * @return the container object
	 */
	protected EObject getContainer(EObject obj) {

		// If the type is not declared return null 
		if (obj instanceof CNode) {
			CNode node = (CNode) obj;
			if (node.getType() == null)
				return null;
			else 
				return node.getType();
		}

		CNodeProperty property = EcoreUtil2.getContainerOfType(obj, CNodeProperty.class);
		CProperty cproperty = (CProperty) property.eGet(DOMLPackage.Literals.CNODE_PROPERTY__NAME, false);

		// If it is a nested property return CProperty
		if (cproperty.getName() != null && cproperty.getProperty().getType().getDatatype() != null)
			return cproperty.getProperty().getType().getDatatype();
		// If it is not a nested property unroll
		else 
			return this.getContainer(obj.eContainer());
	}
	
	/**
	 * Return true if a property has the required attribute set to true
	 * or false otherwise
	 * @return true if required, false otherwise
	 */
	protected boolean isRequired(CProperty property) {
		return property.getProperty().getRequired() != null &&
				property.getProperty().getRequired().isValue();
	}
	
	/**
	 * Check the property type is satisfied, even when using an input 
	 * variable.
	 * @param property
	 */
	@Check
	public void checkPropertyType(CNodeProperty property) {
				
		EObject container = this.getContainer(property.eContainer());
		List<CProperty> props = EcoreUtil2.getAllContentsOfType(container, CProperty.class);
		
		Map<String, CProperty> map = props
				.stream()
				.collect(Collectors.toMap(CProperty::getName, Function.identity()));
		
		CProperty rmdfProperty = map.get(property.getName().getName());

		Handler handler = this.getDispatcher().get(property.getValue().getClass());
		handler.handle(property.getValue(), rmdfProperty, DOMLPackage.Literals.CNODE_PROPERTY__VALUE);

		// Check all values of the property when using multiple true
		if (property.getValue() instanceof CMultipleValueExpression)
			((CMultipleValueExpression) property.getValue()).getValues().forEach((v) -> {
				Handler h = this.getDispatcher().get(v.getClass());
				h.handle(v, rmdfProperty, DOMLPackage.Literals.CNODE_PROPERTY__VALUE);
			});
	}

	/**
	 * Builds a dispatcher based on a HashMap where each class type 
	 * has a handler in order to validate the value types
	 * @return hash map dispatcher
	 */
	private Map<Class<? extends EObject>, Handler> getDispatcher() {	
		Map<Class<? extends EObject>, Handler> dispatcher = new HashMap<Class<? extends EObject>, Handler>();

		// Handler for strings
		Handler cstring = new Handler() {
			public void handle(EObject value, CProperty def, EStructuralFeature feature) {
				String type = this.getType(def.getProperty().getType());
				if (!type.equals("String"))
					error(def.getName() + " should be a " + type, feature);
			}
		};

		// Handler for integer and floats
		Handler cinteger = new Handler() {
			public void handle(EObject value, CProperty def, EStructuralFeature feature) {
				String type = this.getType(def.getProperty().getType());
				if (!type.equals("Integer"))
					error(def.getName() + " should be a " + type, feature);
			}
		}; 

		// Handler for booleans (true and false)
		Handler cboolean = new Handler() {
			public void handle(EObject value, CProperty def, EStructuralFeature feature) {
				String type = this.getType(def.getProperty().getType());
				if (!type.equals("Boolean"))
					error(def.getName() + " should be a " + type, feature);
			}
		}; 

		// Handler for input variables
		Handler cinputvariable = new Handler() {
			public void handle(EObject value, CProperty def, EStructuralFeature feature) {
				String type = this.getType(def.getProperty().getType());
				CInputVariable input = ((CRefInputVariable) value).getInput();
				if (!type.equals(input.getData().getType().getPredefined()))
					error(def.getName() + " should be a " + type + ". "
							+ "Try changing input variable " + input.getName(),
							feature);
			}
		}; 

		// Handler multiple value expressions
		// The handler for the type of each value is made recursively
		Handler cmultiple = new Handler() {
			public void handle(EObject value, CProperty def, EStructuralFeature feature) {
				if (def.getProperty().getMultiple() == null || !def.getProperty().getMultiple().isValue())
					error(def.getName() + " does not support multiple values", feature);
			}
		};

		// Handler nested datatypes
		Handler cnested = new Handler() {
			public void handle(EObject value, CProperty def, EStructuralFeature feature) {
				if (def.getProperty().getType().getDatatype() == null)
					error(def.getName() + " should be a " + this.getType(def.getProperty().getType()), feature);
			}
		};

		dispatcher.put(CSTRINGImpl.class, cstring);
		dispatcher.put(CFLOATImpl.class, cinteger);
		dispatcher.put(CSIGNEDINTImpl.class, cinteger);
		dispatcher.put(CBOOLEANImpl.class, cboolean);
		dispatcher.put(CRefInputVariableImpl.class, cinputvariable);
		dispatcher.put(CMultipleValueExpressionImpl.class, cmultiple);
		dispatcher.put(CNodeNestedPropertyImpl.class, cnested);

		return dispatcher;
	}
	
	/**
	 * Displays a warning if any input variable is not used on a given file.
	 * @param variable
	 */
	@Check
	public void checkUsabilityInputs(CInputVariable variable) {
		
		EObject root = EcoreUtil2.getRootContainer(variable, false);
		List<String> inputs = EcoreUtil2.getAllContentsOfType(root, CRefInputVariable.class)
				.stream()
				.map((i) -> i.getInput().getName())
				.collect(Collectors.toList());
		if (!inputs.contains(variable.getName()))
			warning("Variable not used. May be removed.",
					variable, DOMLPackage.Literals.CINPUT_VARIABLE__NAME);
		
	}

}
