/*
 * generated by Xtext 2.25.0
 */
package org.piacere.dsl.validation

import java.util.ArrayList
import java.util.List
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.piacere.dsl.rMDF.CDataType
import org.piacere.dsl.rMDF.CMultipleNestedProperty
import org.piacere.dsl.rMDF.CMultipleValueExpression
import org.piacere.dsl.rMDF.CNode
import org.piacere.dsl.rMDF.CNodeNestedProperty
import org.piacere.dsl.rMDF.CNodeProperty
import org.piacere.dsl.rMDF.CNodeTemplate
import org.piacere.dsl.rMDF.CNodeTemplates
import org.piacere.dsl.rMDF.CNodeType
import org.piacere.dsl.rMDF.CProperty
import org.piacere.dsl.rMDF.RMDFPackage
import org.piacere.dsl.utils.TreeNode

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RMDFValidator extends AbstractRMDFValidator {

	// public static final String INVALID_NAME = "invalidName"
	
	/**
	 * Check the required properties of a CNode are satisfied.
	 * @param node
	 */
	@Check
	def final void checkNodeRequirements(CNode node) {

		val TreeNode tree = new TreeNode(node.type)
		val Set<CProperty> set = tree.firstLevelProperties.keySet()

		val List<CProperty> props = new ArrayList<CProperty>(set)
		val List<CNodeProperty> properties = node.getProperties()

		this.checkNestedPropertyRequirements(props, properties, RMDFPackage.Literals::CNODE__PROPERTIES)
	}

	/**
	 * Check the required properties of a NestedProperty which is defined
	 * by a datatype are satisfied.
	 * @param node
	 */
	@Check
	def final void checkNodeRequirements(CNodeNestedProperty node) {

		// Leave the multiple check to its own method
		if (EcoreUtil2::getContainerOfType(node, typeof(CMultipleValueExpression)) !== null)
			return

		val datatype = this.getNearestDataType(node)
		val Set<CProperty> set = EcoreUtil2.getAllContentsOfType(datatype, typeof(CProperty)).toSet
		
		val List<CProperty> props = new ArrayList<CProperty>(set)
		val List<CNodeProperty> properties = node.getProperties()

		this.checkNestedPropertyRequirements(props, properties, RMDFPackage.Literals::CNODE_NESTED_PROPERTY__PROPERTIES)
	}

	/**
	 * Check the required properties on a multiple nested property.
	 * @param node
	 */
	@Check
	def final void checkNodeRequirements(CMultipleNestedProperty node) {

		val datatype = this.getNearestDataType(node)
		val Set<CProperty> set = EcoreUtil2.getAllContentsOfType(datatype, typeof(CProperty)).toSet

		val List<CProperty> props = new ArrayList<CProperty>(set)
		val List<CNodeProperty> properties = new ArrayList<CNodeProperty>()
		properties.add(node.getFirst())
		if (node.getRest() !== null)
			properties.addAll(node.getRest().getProperties())

		this.checkNestedPropertyRequirements(props, properties, RMDFPackage.Literals::CMULTIPLE_NESTED_PROPERTY__FIRST)
	}

	/**
	 * Check if all the required properties are actually defined or not.
	 * 
	 * @param defined set of properties definition
	 * @param used set of properties used
	 * @param reference the reference where the error should be displayed
	 */
	def protected void checkNestedPropertyRequirements(List<CProperty> defined, List<CNodeProperty> used,
		EReference reference) {

		val List<String> currentProperties = used.stream().map([prop|prop.getName().getName()]).collect(
			Collectors.toList())

		defined.forEach([ p |
			if (this.isRequired(p) && !currentProperties.contains(p.getName()))
				error('''«p.getName()» property is required'''.toString, reference)
		])
	}

	/**
	 * Return true if a property has the required attribute set to true
	 * or false otherwise
	 * @return true if required, false otherwise
	 */
	def protected boolean isRequired(CProperty property) {
		return property.getProperty().getRequired() !== null && property.getProperty().getRequired().isValue()
	}
	
	/**
	 * Returns the nearest parent defined with a DataType
	 * 
	 * @param object the element from where is started
	 * @return 
	 */
	def protected CDataType getNearestDataType(EObject object) {
		if (object instanceof CNode)
			return null
			
		val parent = EcoreUtil2::getContainerOfType(object, typeof(CNodeProperty))
		val property = parent.eGet(RMDFPackage.Literals::CNODE_PROPERTY__NAME, false) as CProperty
		if (property.name !== null && property.property.type.datatype !== null)
			return parent.name.property.type.datatype
		else 
			return this.getNearestDataType(object.eContainer)
	}
	

	/**
	 * Get dispatcher with the handlers for each terminal type
	 * @return handler
	 */
	def RMDFHandler getDispatcher() {
		return new RMDFHandler([s, f|error(s, f)], RMDFPackage.Literals::CNODE_PROPERTY__VALUE)
	}

	/**
	 * Check the property type is satisfied, even when using an input 
	 * variable.
	 * @param property
	 */
	@Check
	def final void checkPropertyType(CNodeProperty property) {
		val CProperty rmdfProperty = property.getName()
		this.dispatcher.handle(property.value, rmdfProperty)

		if (property.getValue() instanceof CMultipleValueExpression)
			(property.getValue() as CMultipleValueExpression).getValues().forEach([ v |
				this.dispatcher.handle(v, rmdfProperty);
			]);
	}
	
	/**
	 * Check that the node name is unique and is not repeated.
	 * @param template the NodeTemplate
	 */
	@Check 
	def final void checkUniqueNames(CNodeTemplate template) {
		val CNodeTemplates templates = EcoreUtil2.getContainerOfType(template, typeof(CNodeTemplates))
		templates.nodes.forEach[ n |
			if (n !== template && template.name == n.name) {
				val message = '''«n.name» is already used. Names must be unique'''.toString
				this.error(message, RMDFPackage.Literals.CNODE_TEMPLATE__NAME)
			}
		]
	}
	
	/**
	 * Check that the node name is unique and is not repeated.
	 * @param type the node type
	 */
	@Check 
	def final void checkUniqueNames(CNodeType type) {
		val types = type.eResource.allContents.filter(typeof(CNodeType))
		types.forEach[ node |
			if (type !== node && node.name == type.name) {
				val message = '''«node.name» is already used. Names must be unique'''.toString
				this.error(message, RMDFPackage.Literals.CNODE_TYPE__NAME)
			}
		]
	}

}
