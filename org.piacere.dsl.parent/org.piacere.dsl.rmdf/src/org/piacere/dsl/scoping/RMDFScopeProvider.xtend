/*
 * generated by Xtext 2.25.0
 */
package org.piacere.dsl.scoping

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.IResourceDescription
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.piacere.dsl.rMDF.CDataType
import org.piacere.dsl.rMDF.CImport
import org.piacere.dsl.rMDF.CNode
import org.piacere.dsl.rMDF.CNodeCrossRefGetValue
import org.piacere.dsl.rMDF.CNodeProperty
import org.piacere.dsl.rMDF.CNodeRelationship
import org.piacere.dsl.rMDF.CNodeTemplate
import org.piacere.dsl.rMDF.CNodeType
import org.piacere.dsl.rMDF.CProperty
import org.piacere.dsl.rMDF.RMDFPackage
import org.piacere.dsl.utils.TreeNode

/** 
 * This class contains custom scoping description.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class RMDFScopeProvider extends AbstractRMDFScopeProvider {

	@Inject
	ResourceDescriptionsProvider resourceDescriptionsProvider;

	@Inject
	package IResourceDescription.Manager mgr

	override IScope getScope(EObject context, EReference reference) {

		if (reference == RMDFPackage.Literals::CMETADATA__PROVIDER) {
			return super.getScope(context, reference)
		}

		if (reference == RMDFPackage.Literals::CNODE_PROPERTY__NAME) {
			// If it is a nested property -- This line is different from null
			val datatype = this.getNearestDataType(context)
			if (datatype !== null)
				return this.getNestedPropertiesScope(datatype)
			else
				return this.getCPropertiesScope(context)
		}
		
		if (reference == RMDFPackage.Literals::CINTERFACE_CONFIGURE__EXECUTOR ||
			reference == RMDFPackage.Literals::CNODE_RELATIONSHIP_FILTER__FROM) {
			val children = this.getTreeNode(context).leaves.map [
				root.name
			].toList
			return new FilteringScope(super.getScope(context, reference), [ s |
				return children.contains(s.qualifiedName.toString)
			])
		}
		
		if (reference == RMDFPackage.Literals::CNODE_CAPABILITY_TARGETS__TARGETS) {
			val children = this.getTreeNode(context).children.map [
				root.name
			].toList
			return new FilteringScope(super.getScope(context, reference), [ s |
				return children.contains(s.qualifiedName.toString)
			])
		}
		
		if (reference == RMDFPackage.Literals::CNODE_RELATIONSHIP_FILTER__TO) {
			val filter = EcoreUtil2.getContainerOfType(context, typeof(CNodeRelationship)) as CNodeRelationship
			val children = this.getTreeNode(filter.value).leaves.map [
				root.name
			].toList
			return new FilteringScope(super.getScope(context, reference), [ s |
				return children.contains(s.qualifiedName.toString)
			])
		}

		if (reference == RMDFPackage.Literals::CNODE__TYPE ||
			reference == RMDFPackage.Literals::CNODE_TYPE_DATA__SUPER_TYPE) {
			return new FilteringScope(this.getImportedScope(context, reference), [ s |
				var EObject obj = s.getEObjectOrProxy()
				return (obj instanceof CNodeType) && obj !== context
			])
		}
		
		if (reference == RMDFPackage.Literals::CDATA_TYPE_DATA__SUPER_TYPE) {
			return new FilteringScope(this.getImportedScope(context, reference), [ s |
				var EObject obj = s.getEObjectOrProxy()
				return (obj instanceof CDataType) && obj !== context
			])
		}

		if (reference == RMDFPackage.Literals::CNODE_CROSS_REF_GET_VALUE__CROSSVALUE &&
			(context as CNodeCrossRefGetValue).isSuper()) {
			val CNodeType container = EcoreUtil2::getContainerOfType(context, typeof(CNodeType))
			val supertype = container.data.superType
			if (supertype !== null && !supertype.eIsProxy) {
				val resourceDescriptions = this.getResourceDescriptions(context)
				val tree = new TreeNode(supertype, QualifiedName.create(supertype.name), resourceDescriptions)
				val properties = tree.firstLevelProperties
				return Scopes.scopeFor(properties.keySet, IScope.NULLSCOPE)
			} else {
				return IScope.NULLSCOPE
			}
		}

		val EObject root = EcoreUtil2::getRootContainer(context)
		return new FilteringScope(super.getScope(context, reference), [ s |
			var EObject inneroot = EcoreUtil2::getRootContainer(s.getEObjectOrProxy())
			return root.equals(inneroot)
		])
	}
	
	/**
	 * Returns the resource descriptions for the context
	 * 
	 * @param context the element
	 * @return
	 */
	def protected IResourceDescriptions getResourceDescriptions(EObject context) {
		val Resource resource = context.eResource
		return resourceDescriptionsProvider.getResourceDescriptions(resource)
	}

	/**
	 * Returns a scope of the given context only for imported namespace
	 * 
	 * @param context the element from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return
	 */
	def protected IScope getImportedScope(EObject context, EReference reference) {
		val EObject root = EcoreUtil2::getRootContainer(context)
		val List<CImport> imports = EcoreUtil2::getAllContentsOfType(root, typeof(CImport))

		return new FilteringScope(super.getScope(context, reference), [ s |
			// If it is on the same file, we do not need an import
			var EObject inneroot = EcoreUtil2::getRootContainer(s.getEObjectOrProxy())
			if (root.equals(inneroot))
				return true

			return imports.stream().anyMatch([ i |
				if (i.getImportedName() === null)
					return false
				var QualifiedName importedName = QualifiedName.create(i.getImportedName().split("\\."))
				if (importedName.getLastSegment().equalsIgnoreCase("*")) {
					importedName = importedName.skipLast(1)
					return s.getQualifiedName().startsWithIgnoreCase(importedName)
				} else {
					return s.getQualifiedName().equals(importedName)
				}
			])
		])
	}
	
	/**
	 * Returns the scope for all the CProperties available
	 * 
	 * @param context the element from which extract the CProperties
	 * @return 
	 */
	def protected IScope getCPropertiesScope(EObject context) {
		val tree = this.getTreeNode(context)

		val properties = tree.allCProperties
		return Scopes.scopeFor(properties.keySet, [ s |
			return properties.get(s).skipFirst(1)
		], IScope.NULLSCOPE)
	}
	
	/**
	 * Returns the TreeNode object of the context finding the container CNodeTemplate
	 * 
	 * @param context the context we are working on
	 * @return 
	 */
	def protected TreeNode getTreeNode(EObject context) {
		val resourceDescriptions = this.getResourceDescriptions(context)			
		val cont = EcoreUtil2::getContainerOfType(context, typeof(CNodeTemplate))
		val type = cont?.template?.eGet(RMDFPackage.Literals::CNODE__TYPE, true) as CNodeType
		return new TreeNode(type, QualifiedName.create(cont.name), resourceDescriptions)
	}
	
	/**
	 * Returns the scope of a nested property (CDataType) structure
	 * 
	 * @param object the element from which extract the CProperties
	 * @return 
	 */
	def protected IScope getNestedPropertiesScope(CDataType datatype) {
		val properties = EcoreUtil2.getAllContentsOfType(datatype, typeof(CProperty))
		var supertype = datatype.data.superType
		while(supertype !== null) {
			properties.addAll(EcoreUtil2.getAllContentsOfType(supertype, typeof(CProperty)))
			supertype = supertype.data.superType
		}
		return Scopes.scopeFor(
			properties,
			IScope.NULLSCOPE
		)
	}
	
	/**
	 * Returns the nearest parent defined with a DataType
	 * 
	 * @param object the element from where is started
	 * @return 
	 */
	def protected CDataType getNearestDataType(EObject object) {
		if (object instanceof CNode)
			return null
			
		val parent = EcoreUtil2::getContainerOfType(object, typeof(CNodeProperty))
		val property = parent.eGet(RMDFPackage.Literals::CNODE_PROPERTY__NAME, false) as CProperty
		if (property.name !== null && property.property.type.datatype !== null)
			return parent.name.property.type.datatype
		else 
			return this.getNearestDataType(object.eContainer)
	}

}
