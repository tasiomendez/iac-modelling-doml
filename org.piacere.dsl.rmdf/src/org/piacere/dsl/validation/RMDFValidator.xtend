/*
 * generated by Xtext 2.25.0
 */
package org.piacere.dsl.validation

import java.util.ArrayList
import java.util.List
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.piacere.dsl.rMDF.CMultipleNestedProperty
import org.piacere.dsl.rMDF.CMultipleValueExpression
import org.piacere.dsl.rMDF.CNode
import org.piacere.dsl.rMDF.CNodeNestedProperty
import org.piacere.dsl.rMDF.CNodeProperty
import org.piacere.dsl.rMDF.CProperty
import org.piacere.dsl.rMDF.RMDFPackage
import org.piacere.dsl.utils.Helper

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RMDFValidator extends AbstractRMDFValidator {

	//	public static final String INVALID_NAME = "invalidName"

	/**
	 * Check the required properties of a CNode are satisfied.
	 * @param node
	 */
	@Check
	def final void checkNodeRequirements(CNode node) {

		var Set<CProperty> set = Helper::getAllCProperty(node, false).keySet()
		var List<CProperty> props = new ArrayList<CProperty>(set)
		var List<CNodeProperty> properties = node.getProperties()

		this.checkNestedPropertyRequirements(props, properties, 
				RMDFPackage.Literals::CNODE__PROPERTIES)
	}

	/**
	 * Check the required properties of a NestedProperty which is defined
	 * by a datatype are satisfied.
	 * @param node
	 */
	@Check
	def final void checkNodeRequirements(CNodeNestedProperty node) {

		// Leave the multiple check to its own method
		if (EcoreUtil2::getContainerOfType(node, typeof(CMultipleValueExpression)) !== null)
			return
		
		var Set<CProperty> set = Helper::getAllCProperty(node, false).keySet()
		var List<CProperty> props = new ArrayList<CProperty>(set)
		var List<CNodeProperty> properties = node.getProperties()

		this.checkNestedPropertyRequirements(props, properties,
				RMDFPackage.Literals::CNODE_NESTED_PROPERTY__PROPERTIES)
	}

	/**
	 * Check the required properties on a multiple nested property.
	 * @param node
	 */
	@Check
	def final void checkNodeRequirements(CMultipleNestedProperty node) {
		
		var Set<CProperty> set = Helper::getAllCProperty(node, false).keySet()
		var List<CProperty> props = new ArrayList<CProperty>(set)
		var List<CNodeProperty> properties = new ArrayList<CNodeProperty>()
		properties.add(node.getFirst())
		if (node.getRest() !== null)
			properties.addAll(node.getRest().getProperties())

		this.checkNestedPropertyRequirements(props, properties,
				RMDFPackage.Literals::CMULTIPLE_NESTED_PROPERTY__FIRST)
	}

	/**
	 * Check if all the required properties are actually defined or not.
	 * 
	 * @param defined set of properties definition
	 * @param used set of properties used
	 * @param reference the reference where the error should be displayed
	 */
	def protected void checkNestedPropertyRequirements(List<CProperty> defined, 
			List<CNodeProperty> used,
			EReference reference) {

		val List<String> currentProperties = used
				.stream()
				.map([prop | prop.getName().getName() ])
				.collect(Collectors.toList())
		
		defined.forEach([ p |
			if (this.isRequired(p) && !currentProperties.contains(p.getName()))
				error('''«p.getName()» property is required'''.toString, reference)
		])
	}

	/**
	 * Get container of a given EObject. The container could be a nested property
	 * which is declared with a Datatype or a CNode.
	 * @param obj object
	 * @return the container object
	 */
	def protected EObject getContainer(EObject obj) {

		// If the type is not declared return null 
		if (obj instanceof CNode) {
			var node = obj as CNode
			return node.getType()
		}

		var property = EcoreUtil2::getContainerOfType(obj, typeof(CNodeProperty))
		var cproperty = property.eGet(RMDFPackage.Literals::CNODE_PROPERTY__NAME, false) as CProperty 

		// If it is a nested property return CProperty
		if (cproperty.getName() !== null && cproperty.getProperty().getType().getDatatype() !== null) {
			return cproperty.getProperty().getType().getDatatype()
		// If it is not a nested property unroll
		} else {
			return this.getContainer(obj.eContainer())
		}
	}

	/**
	 * Return true if a property has the required attribute set to true
	 * or false otherwise
	 * @return true if required, false otherwise
	 */
	def protected boolean isRequired(CProperty property) {
		return property.getProperty().getRequired() !== null &&
				property.getProperty().getRequired().isValue()
	}

	/**
	 * Get dispatcher with the handlers for each terminal type
	 * @return handler
	 */
	def RMDFHandler getDispatcher() {
		return new RMDFHandler([ s, f | error(s, f) ], RMDFPackage.Literals::CNODE_PROPERTY__VALUE)
	}

	/**
	 * Check the property type is satisfied, even when using an input 
	 * variable.
	 * @param property
	 */
	@Check
	def final void checkPropertyType(CNodeProperty property) {
		val CProperty rmdfProperty = property.getName()
		this.dispatcher.handle(property.value, rmdfProperty)
		
		if (property.getValue() instanceof CMultipleValueExpression)
			(property.getValue() as CMultipleValueExpression).getValues().forEach([ v |
				this.dispatcher.handle(v, rmdfProperty);
			]);
	}

}
