/*
 * generated by Xtext 2.25.0
 */
package org.piacere.dsl.scoping

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.IResourceDescription
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.piacere.dsl.rMDF.CDataType
import org.piacere.dsl.rMDF.CImport
import org.piacere.dsl.rMDF.CNode
import org.piacere.dsl.rMDF.CNodeCrossRefGetValue
import org.piacere.dsl.rMDF.CNodeProperty
import org.piacere.dsl.rMDF.CNodeTemplate
import org.piacere.dsl.rMDF.CNodeType
import org.piacere.dsl.rMDF.CProperty
import org.piacere.dsl.rMDF.RMDFPackage
import org.piacere.dsl.utils.TreeNode
import org.piacere.dsl.rMDF.CNodeRelationship

/** 
 * This class contains custom scoping description.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class RMDFScopeProvider extends AbstractRMDFScopeProvider {

	@Inject
	IResourceDescriptions descriptions

	@Inject
	package IResourceDescription.Manager mgr

	override IScope getScope(EObject context, EReference reference) {

		if (reference == RMDFPackage.Literals::CMETADATA__PROVIDER) {
			return super.getScope(context, reference)
		}

		if (reference == RMDFPackage.Literals::CNODE_PROPERTY__NAME) {
			// If it is a nested property -- This line is different from null
			val datatype = this.getNearestDataType(context)
			if (datatype !== null)
				return this.getNestedPropertiesScope(datatype)
			else
				return this.getCPropertiesScope(context)
		}
		
		if (reference == RMDFPackage.Literals::CINTERFACE_CONFIGURE__EXECUTOR ||
			reference == RMDFPackage.Literals::CNODE_RELATIONSHIP_FILTER__FROM) {
			val children = this.getTreeNode(context).leaves.map [
				root.name
			].toList
			return new FilteringScope(super.getScope(context, reference), [ s |
				return children.contains(s.qualifiedName.toString)
			])
		}
		
		if (reference == RMDFPackage.Literals::CNODE_RELATIONSHIP_FILTER__TO) {
			val filter = EcoreUtil2.getContainerOfType(context, typeof(CNodeRelationship)) as CNodeRelationship
			val children = this.getTreeNode(filter.value).leaves.map [
				root.name
			].toList
			return new FilteringScope(super.getScope(context, reference), [ s |
				return children.contains(s.qualifiedName.toString)
			])
		}

		if (reference == RMDFPackage.Literals::CNODE__TYPE ||
			reference == RMDFPackage.Literals::CNODE_TYPE_DATA__SUPER_TYPE) {
			return new FilteringScope(this.getImportedScope(context, reference), [ s |
				var EObject obj = s.getEObjectOrProxy()
				return (obj instanceof CNodeType)
			])
		}

		if (reference == RMDFPackage.Literals::CNODE_CROSS_REF_GET_VALUE__CROSSVALUE &&
			(context as CNodeCrossRefGetValue).isSuper()) {
			val CNodeType container = EcoreUtil2::getContainerOfType(context, typeof(CNodeType))
			if (container.data.superType !== null) {
				val properties = container.data.superType?.data.properties
				return Scopes.scopeFor(properties, IScope.NULLSCOPE)
			} else {
				return IScope.NULLSCOPE
			}
		}

		val EObject root = EcoreUtil2::getRootContainer(context)
		return new FilteringScope(super.getScope(context, reference), [ s |
			var EObject inneroot = EcoreUtil2::getRootContainer(s.getEObjectOrProxy())
			return root.equals(inneroot)
		])
	}

	/**
	 * Returns a scope of the given context only for imported namespace
	 * 
	 * @param context the element from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return
	 */
	def protected IScope getImportedScope(EObject context, EReference reference) {
		val EObject root = EcoreUtil2::getRootContainer(context)
		val List<CImport> imports = EcoreUtil2::getAllContentsOfType(root, typeof(CImport))

		return new FilteringScope(super.getScope(context, reference), [ s |
			// If it is on the same file, we do not need an import
			var EObject inneroot = EcoreUtil2::getRootContainer(s.getEObjectOrProxy())
			if (root.equals(inneroot))
				return true

			return imports.stream().anyMatch([ i |
				if (i.getImportedName() === null)
					return false
				var QualifiedName importedName = QualifiedName.create(i.getImportedName().split("\\."))
				if (importedName.getLastSegment().equalsIgnoreCase("*")) {
					importedName = importedName.skipLast(1)
					return s.getQualifiedName().startsWithIgnoreCase(importedName)
				} else {
					return s.getQualifiedName().equals(importedName)
				}
			])
		])
	}
	
	/**
	 * Returns the scope for all the CProperties available
	 * 
	 * @param context the element from which extract the CProperties
	 * @return 
	 */
	def protected IScope getCPropertiesScope(EObject context) {
		val tree = this.getTreeNode(context)

		val properties = tree.allCProperties
		return Scopes.scopeFor(properties.keySet, [ s |
			return properties.get(s).skipFirst(1)
		], IScope.NULLSCOPE)
	}
	
	/**
	 * Returns the TreeNode object of the context finding the container CNodeTemplate
	 * 
	 * @param context the context we are working on
	 * @return 
	 */
	def protected TreeNode getTreeNode(EObject context) {
		val cont = EcoreUtil2::getContainerOfType(context, typeof(CNodeTemplate))
		val type = cont?.template?.eGet(RMDFPackage.Literals::CNODE__TYPE, true) as CNodeType
		return new TreeNode(type, QualifiedName.create(cont.name), descriptions)
	}
	
	/**
	 * Returns the scope of a nested property (CDataType) structure
	 * 
	 * @param object the element from which extract the CProperties
	 * @return 
	 */
	def protected IScope getNestedPropertiesScope(CDataType datatype) {
		return Scopes.scopeFor(
			EcoreUtil2.getAllContentsOfType(datatype, typeof(CProperty)),
			IScope.NULLSCOPE
		)
	}
	
	/**
	 * Returns the nearest parent defined with a DataType
	 * 
	 * @param object the element from where is started
	 * @return 
	 */
	def protected CDataType getNearestDataType(EObject object) {
		if (object instanceof CNode)
			return null
			
		val parent = EcoreUtil2::getContainerOfType(object, typeof(CNodeProperty))
		val property = parent.eGet(RMDFPackage.Literals::CNODE_PROPERTY__NAME, false) as CProperty
		if (property.name !== null && property.property.type.datatype !== null)
			return parent.name.property.type.datatype
		else 
			return this.getNearestDataType(object.eContainer)
	}

}
